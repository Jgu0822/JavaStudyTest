.jar 자바의 압축파일명(자바 클래스 파일을 압축)
**패키지 단위로 압축
"패키지" >>package: 비슷한 기능의 클래스를 모아둔 디렉토리(폴더)
"라이브러리" >>미리 사용할 목적으로 만들어 놓은 패키지"

rt.jar// 자바의 기본 라이브러리
java.lang;//자바의 기본패키지
System. class
https://docs.oracle.com/javase/8/docs/api/            // 구조 공부 사이트

"java를 배운다는 것은" ->라이브러리를 공부하는 것

=======================================
**자바프로젝트 생성 순서 -> ctrl+N, 우클릭(바로가기)

1.프로젝트: "패키지 단위"
1)프로젝트 명
2)패키지생성 도메인 역순 http://www.daum.net com.naver.
com.java......
org.java..
<1>변수 variable
org.java.variableEx 

3) 클래스 생성 -> 첫글자 대문자
키워드(예약어): 이미 존재하는 클래스명
=======================================


자바소스 실행-> 
1. 우클릭 (Run as ->자바 어플리케이션)
2. 메뉴 (Run as ->자바 어플리케이션)
3. ctrl + F11
=======================================

변수: "하나의 data(자료)를 저장 할 수 있는 공간"
2가지 의미
1) 저장공간 (주소)
2) 참조값 (메모리가 참조하는 값)


=======================================
data(자료) -> 텍스트, 이미지 , 파일 , 동영상, 객체,,,,

1. 변수를 선언   -> 기본적으로 같은 공간에서 같은 이름의 변수명을 사용할 수 없다.
2. 변수를 초기화 -> data를 추가
3. 변수를 메모리에 할당

 =======================================

**주석 -> 컴파일 X 설명글
//  한줄 주석 
/*  
        여러줄 주석
 /*

========================================

bit: data의 기본단위         1bit는 0,1
byte: 메모리의 기본단위 

1byte = 8bit      -128~+127 = 256


자바의 기본자료형 primitive types
            1           2          4          8
정수형 byte       short      int        long
실수형                          float     double
문자형              char
논리형 boolean


정수형 1, 2, 3 ,4, -190      =int(자바 기본형)
실수형 소수점 1.23  3.33  =double(자바 기본형)
문자형 'a' 하나의 문자     = C언어에서는 1바이트
논리형 true, false 

1 byte  = 8bit      -2^7  ~ +2^7-1     = -128~ +127
1 short = 16 bit   -2^15 ~ +2^15-1   = -32,768 ~ 32,767
1 int     = 32bit    -2^31 ~ +2^31-1  

클래스명. 속성. 매서드
System.out.println("기본 자료형" );
System.out.println("문자열" +변수);
//콘솔에 출력 -> 문자형은 그대로, 변수의 참조값이 출력
int i =10;
System.out.println("i->" +i);
출력 -> i -> 10


==================================

**자바의 primitive type**   - data 1개
           1      2       4      8
정수형 byet  short  int    long
실수형                 float  double
문자형         char
논리형boolean

==================================

** 자바의 객체형 타입** {속성:값,,,,} -> 메모리 주소

참조형(객체형==Object형) new객체();
String, class, interface
(문자)
참조형기본 >> null

class>>"사용자정의타입"

==================================

**변수이름**

키워드(예약어)를 사용할 수 없다.
숫자로 시작하지  X
공백허용 X
_,$이외의 특수문자 X
대소문자로 구분한다 
소문자로 시작하자
다른 문자가 시작되면 대문자로 시작하자.
한글은 사용하지 말자.

==================================

**변수의 종류** -> class수업 다시 설명

1. 인스턴스맴버(인스턴스 변수): 클래스 내부의 변수 -> 인스턴스를 생성한 후 접근
2. 클래스 맴버(클래스 변수)     : 인스턴스를 생성하지 않아도 접근 가능
3.지역변수(매서드안에 선언)    :매서드안의 변수
4.지역변수(매개인자)              :매서드 매개인자
5.객체 참조 변수                    : 객체(인스턴스)의 주소값을 저장

===================================

**상수** ->상수란 수식에서 변하지 않는 값을 의미한다.
상수의 선언 
final 상수타입 상수명;
final int MAN;
상수의 사용
상수명=값;
J=10; (J에는 값을 담을 수 있는 기회가 단 한번만 허락됨)

상수 명명에 
대문자로만,
여러단어로 구성된 이름의 경우 '_'를 붙여서 구분함.

상수를 사용해야 하는 경우
변하지 않는 값 >> 상수를 사용
의미 있는 값>> 상수를 사용

=====================================
casting(형(type)변환
자동형변환
1. 큰자료형 + 작은 자료형 >> 큰자료형+큰자료형
int + double = double + double
int i= 10+1.1
double d= 10+1.1

2. int형 아래 자료형의 연산시 자동으로 int형으로 변환
byte b= 10;
byte b2=10;
byte b3=b+b2; //byte +byte =int +int

int b3= b+b2;
byte b3=(byte)(b+b2);

강제형변환(프로그래머가 직접)
(자료형)data;

int i=(int)1.1;           //data의 손실
int i2=10+(int)1.1;    //0.1 단위 사라짐

byte b1=10;
byte b2=20;
byte b3=(byte)(b1+b2);

java.lang -> 자바의 기본패키지, import를 할 필요가 없다.
System.out.println("강제형변환"); //콘솔에 출력

**Scanner** -> 콘솔에서 입력 java.utol 패키지, import java.util.Scanner

1. String(문자열)로 입력 받고 싶으면 next() 나 nextLine() -> enter전
2. int(정수)로 입력 받고 싶다면 nextlnt()를 사용하여 입력받으면 알아서 해당타입으로 입력된다.
3. 공백(띄어쓰기) 또는 개행(줄 바꿈)을 기준으로 읽는다.
============================================================
java primitve types
           1        2      4       8
정수형 byte   short   int     long
실수형                  float   double
문자형          char
논리형 boolean
===========================================================

int i;  //int형 type의 변수 i를 선언했다.
i=10; //int형 type의 변수 i를 10으로 초기화했다.
int i=10;

============================================================

***java 객체형 types***

new 객체형();

String -> "문자열"
             String str1=new String();
                     str1="문자열";
             String str2="문자열";   //보통 시

배열 -> new Array();
           int[] arr1 =new Array();
           int[] arr2={1,2,3,4,5};

class -> 객체를 만드는 설계도
          java library
         사용자 정의 클래스(프로그래머가 직접 생성)

interpace ->new를 생성못한다.
             
============================================================

시스템의 출력 
System.out.println();                // 계행
System.out.print();                  // 이름:
system.out.printf("%d", 10);     // 서식문자, 출력값

시스템의 입력
scanner -> 문자, 정수, 실수, boolean, 문자열,, 입력
java.utill.Scanner; -> rt.jar

Scanner csn=new Scanner(System.in);          // in은 입력out은 출력
scn.next();                                               // 문자열 입력(공백 X), 단어    "이름", "문자열"
scn.nextLine();                                         // 문자열 입력 (공백O),          "문자열 입력 123"
scn.nextInt();                                           // 정수형 입력
scn.nextDouble();                                     // 실수형 입력

문자열: String addr=scn.nestLine(); 
============================================================

연산: 데이터를 처리(계산,일)하여 결과를 산출하는 것을 연산(operation)

***연산자(operator)***
연산을 하는 기호 +-*/

피연산자(operand): 연산에 대상(항)
5+8 ,5-8 ,5*8, 5/8
============================================================

1. 단항 연산자
증감 연산자 -> 반복문과 많이 사용
++
--

int i=0;
i++;    //1증가
i--;      //1감소

i++;   //선처리 후 증가
++i;   //선증가 후 처리
i--;    //선처리 후 감소
--i;    //선감소 후 처리

int i=10;
System.out.println(i++);  // 선처리 후 증가 10
System.out.println(i);      // 11
System.out.println(++i); // 선증가 후 처리 12
System.out.println(i);      // 12
System.out.println(i--);  // 선처리 후 감소 12
System.out.println(i);      // 11
System.out.println(--i); // 선감소 후 처리 10

증감연산자-> 반복문(for)과 많이 사용
for문은 선처리 후 증가 
for(초기화;조건식;증감식){

		//조건식이 true실행문(명령문),처리
}
------------------------
   i         i<10 i++
------------------------
0              true 1
 1              true 2
  2              true 3
......9              true 10
...10          false
------------------------
for(int i=0;i<10;i++){


}




============================================================

2. ★이항 연산자★

1)산술 연산자

+ 더하기
- 빼기
* 곱하기 
/ 나누기
% 나누고 몫

숫자+숫자->숫자
숫자+"문자열"->문자열
10+"10" -> "1010"
10+"10"+10 -> "1010"+"10" -> "101010"
10+10+"10" -> 20+"10" -> "2010"
"10"+(10+10) -> "10"+20 -> "1020"
System.out.println(변수+"문자열");

============================================================
2)대입 연산자 -> 연산의 결과를 변수에 대입하는 연산자
int num=10;
**Primirive type:기본자료형(8가지)
int num=10;    //실제 data값을 대입

**Referce :참조형타입(String, 배열, class, interface)
**객체형(Object형)
//객체참조변수(객체의 주소값을 저장)
//new -> 객체를 생성

String str=new String("userld");  //str은 객체참조변수
. -> 객체 접근 연산자
str.속성;
str.매서드();

복합대입연산자 
int num=10;

num=num+10;
num+=10; // 복합 대입연산자.(누적)

num=num-10;
num-=10;

num*=10;
num=num*10;

num/=10;
num=num/10;

num%=10;
num=num%10;

============================================================

3)비교 연산자 -> "왼쪽"
연산의 결과는 ture, false로 반환(return)
**제어문(조건문)(if,switch)와 같이 사용하는 경우가 많다.

>       ->크냐?
10>20

>=     ->크거나 같냐?
10>=20

<       ->작냐?
10<20

<=     ->작거나 같냐?
10<=20

==     ->같냐?
10==20

!=      ->같지 않냐?
10!=20

**==문자일 경우**

int i =10;
== -> premitive type 비교, 단순, 주소값비교

문자열(객체) 비교시 -> 문자열 객체의 값을 비교(equals 사용)
객체1.equals(객체2);

String id="11";
strAge.equals("11");

예시)
		 int age=11;
		 String strAge="11";

		 System.out.println(age==11);
		 System.out.println(strAge.equals("11"));

============================================================	
	
4)논리 연산자(&&, ||, ^, !)

논리곱(모든 조건이 true일 때만 true)

조건1 && 조건2 결과 -> and게이트
true         true   true
true         false  false
false        true   false
false        false   false

논리합(하나이상의 조건이 true일 때 true) 
조건1 || 조건2 결과 -> or
true      true   true
true      false   true
false     true    true
false     false   false

Xor (서로 다르면 ture) Xor게이트
조건1 ^ 조건2 결과
true      true    false
true      false   true
false     true    true
false     false   false
 
!(부정)  ->toggle(토글)현상 - 같은 이벤트를 적용시 반복적으로 반대효과
조건     결과
! true    false;
! false   false;

============================================================

5)조건 연산자 ->삼항연산자 ->실무(프론트 등)에서 많이 사용(조건이 2개일 경우)

?:
                    조건식?조건이true:나머지;

int result=      10>10?      1        :0;
int result=10>10?1:0;

if(10>10){
	//1
}else{
	//0
}

============================================================

6)비트 연산자

**비트연산자 2진수 
        &   결과
1      1      1
1      0      0
0      1      0
0      0      0

10          1010  ↓
12     &   1100
8            1000


      |   결과
1    1    1
1    0    1
0    1    1
0    0    0

10진수   2진수
10          1010  ↓
12       |  1100
14          1110


^(xor)  결과  -> 서로 다르면 1
1    1    0
1    0    1
0    1    1
0    0    0

10진수  2진수 ↓
10         1010
12      ^ 1100
6           0110

~(not)
10진수  2진수  
10        1010
         ~ 0101

0  000000000
1  11111111


int i1 = 10;
int i2 = 0b111;       //2진수
int i3 = 0111;	//8진수
int i4 = 0xaaa;	//16진수


**Wrapper클래스
Integer.toBinaryString( int형 data);
int형 data ->String 2진수형으로 변경

Integer.toBinaryString(num1&num2);


============================================================

7)쉬프트 연산자

오른쪽 쉬프트 : 작아진다. 2^n
10>>2
     1010.
        10.10
**소수점 이하는 삭제
왼쪽 쉬프트 : 커진다. 2^n
10<<2
      1010.
   101000.
**빈자리는 0으로 채운다.

============================================================

3. 삼항 연산자
?:

int num=10;
		
		int result = num>10?1:0;
		System.out.println("결과: "+result);
		
		boolean bool = num>10?true:false;
		System.out.println("결과: "+bool);
		
		String str = num>10?"10보다 크다.":"10보다 크지 않다.";
		System.out.println("결과: "+str);

============================================================
***아스키 코드:영문,특수기호,미국, 0~127 -> 11월 01일 pdf확인
11월 1일 - Quiz1
정수(0~127)와 1대1로 대칭
알파벳 26자

대문자에서 소문자 +
소문자에서 대문자-

대소문자 차이:32
A  65        a  97       =162
'Z' 90       'z' 122

char c1='A';
int c2='A'; 

'A'+31 -> 97 -> (char)97 -> 'a'


.next().charAt(0); ->char형 data입력

char ch=input.next().charAt(0);






============================================================
**제어문(조건문) -> 조건에 맞으면 true, 틀리면 false

1. if문

-조건이 1개일 경우-

if(조건){
	//조건이 true일 때만 실행(처리)
}
if(조건){
	//조건이 true이면 처리

예) 아이디 체크...
콘솔->아이디를 입력.. 임시 -> idr가 "root"
아이디를 입력 "root"


if(조건) //명령문;

int i=10;

if(i>10){
	//명령문(처리문)
	"10보다 큽니다";
}


-조건이 2개일 경우-

if(조건){
	//조건이 true일 때만 실행
}else{
	//조건이 true가 아닐 때 실행 
}


-조건이 2개 이상일 경우-

if(조건1){
	//1true
}else if(조건2){
	//2true
}else if(조건3){
	//3true
}else if(조건4){
	//4true
}else{
	//나머지
}

//조건중에 true 조건을 만족하는 명령문을 실행
//if~else if문을 종료


if(조건1){
	//조건1true
}else if(조건2){
	//조건2true
}else if(조건3){
	//조건3true
}else{
	//조건4true
}


//90점 이상이면 A, 95점 이상이면 A+
//95점 이상 ->90점 이상 범위안에서 설정

if(kor>=90) {
	if(kor>=95) {
	System.out.println("A+");
}
else {System.out.println("A");}
}
============================================================
2. switch문 ->모든 switch문은 if 문으로 바꿀 수 있다.
switch~case...조건의 결과가 정수형 타입의 값, 하나 결과

switch(변수(설정값)){
case "값1"://변수(설정값)이 값1이면 
	처리문;
	break;//switch문을 종료
case "값2"://변수(설정값)이 값2이면 
	처리문;
	break;//switch문을 종료
case "값3"://변수(설정값)이 값3이면 
	처리문;
	break;//switch문을 종료
default:
	나머지처리문;//else,생략가능...
}//switch문을 종료 

**switch문은 모든 값을 if 문을 바꿀 수는 없다.


Ex)
System.out.println("Switch");

		Scanner input = new Scanner(System.in);
		System.out.println("Key 값을 입력하세요: ");
		int key = input.nextInt();

		switch (key) {
		case 1:
			System.out.println("관리자 권한");
			break;
		case 2:
			System.out.println("중간관리자 권한");
			break;
		case 3:
			System.out.println("일반 사원 권한");
			break;
		default:
			System.out.println("접속불가... 관리자에게 문의 하세요.");


***break ->그 지점에서 아래 명령문을 실행하지 않고 코드블럭을 벗어난다.
             ->매서드를 종료, "반복문 안"의 if, switch문 조건문을 종료, 반복문 종료

***변수(설정값) -> 결과값: 정수형, 문자, 문자열**범위



============================================================
============================================================
****반복문 ->반복적인 명령문을 처리

1. for (☆무조건 선처리 후 증가☆)
***조건이 false면 한번도 실행하지 않는다.

for(초기화;조건식;증감식){
		//조건이 ture면 처리
}

구구단 

2*1=2
2*2=4
2*3=6
2*4=8
   .
2*9=18

System.out.println("구구단 1");

		for (int i = 2; i < 10; i++) {
			System.out.println(i + "단 입니다.");

			for (int j = 1; j < 10; j++) {
				// 2*1=2
				System.out.println(i + "*" + j + "=" + (i * j));
			}
		}

============================================================
2. while -> 데이터베이스의 data를 불러오는데 많이 사용
           -> 무한 루프 주의
***조건이 ture이면 실행, false면 실행 안할 수도 있음.
***조건이 false면 한번도 실행하지 않는다.
초기화

while(조건식){
	//명령문(처리,실행)

	증감식;
}

구구단 출력
System.out.println("while");
		
		System.out.println("구구단(2단~9단)");
		
		int i=2;
		
		while(i<10) {
			System.out.println(i+"단 입니다.");
			
			int j=1;
			while(j<10) {
				System.out.println(i+"*"+j+"="+i*j);
				j++;
			}	
			i++;

***break ->그 지점에서 아래 명령문을 실행하지 않고 코드블럭을 벗어난다.
             ->매서드를 종료, "반복문 안"의 if, switch문 조건문을 종료, 반복문 종료

***continue -> 그 지점에서 아래 명령문을 실행하지 않고 코드블럭 끝에서 다시 시작

============================================================
3. do~while ->while문과 거의 같다.
**무조건 한 번은 실행
**한 번 반드시 실행하는 프로젝트 사용

int i=0; //1. 초기화
do{
	//증감식;

}while(조건); //2. 조건식

============================================================
4. 객체형 반복문 -> 컬렉션 프레임 워크 때 할 것 
**foreach -> 입력된 모든 객체의 data를 get 할 수 있다. 

for(자료형 변수명: 배열명){
	// 
}


============================================================
For문과 친구친구
배열: 다량의 data를 처리하기 위한 List형(순서가 있는)의 타입이다.
1. 같은 타입의 data를 순서대로 그룹화
2. 인덱스 (번지,요소)는 0번지 부터 시작된다.
3. 배열의 갯수는 고정한다. >> 컬렉션 ..고정X
4. 배열 참조형 (객체형) 타입 (배열의 전체 주소 값으로 접근 ).. new 배열라면
5. 배열의 생성과 동시 초기화 해야된다.
6. 값을 초기화 하지 않으면 0으로 초기화 된다.
7. 반복문(for)과 같이 많이 사용된다.
8. 전체 배열의 data 갯수는 전체의 인덱스 총수보다 1크다.
9. 배열의 이름에 전체 배열의 주소값을 저장한다.
10. foreach. (DB의 data를 가져올(get 할) 때) - 객체형 반복문이다.


배열 선언

//int배열 arr1를 선언하고 초기화 하였다.
int[] arrint=new int[5]; 
		// int형 타입의 data 5개를 저장할 수 있는 배열을 생성했다!  

배열 EX) 1~10까지 출력

System.out.println();
		
		int[] arr1=new int[10];
		
		for(int s=0; s<10;s++) {
			arr1[s]= s+1;
			System.out.println(arr1[s]);
		}

============================================================
System.out.println(arr1);
			
	arr1[0]=10; // arr1 0번지를 10으로 초기화
	arr1[1]=20; // arr1 1번지를 20으로 초기화
	arr1[2]=30; // arr1 2번지를 30으로 초기화
	arr1[3]=40; // arr1 3번지를 40으로 초기화
	arr1[4]=50; // arr1 4번지를 50으로 초기화
			
	System.out.println(arr1[0]);
	System.out.println(arr1[1]);
	System.out.println(arr1[2]);
	System.out.println(arr1[3]);
	System.out.println(arr1[4]);

객체형(Object)
String, 배열, class(library, 사용자 정의 타입), interface

// 변수(객체 참조 변수: 객체의 주소값이 저장) -> new 하면 주소 생성
객체형 타입 변수 =new 객체형(); 
. -> 객체접근 연산자

변수.

로또 -> 1~45

random -> 무작위

Math.random(); //클래스 매서드 -> 클래스명.매서드();

0<=Math.random()<1
0~0.9999999....

0*10<=Math.random()*10<1*10
0<= 9.9999...

0*46<=Math.random()*46<1*46
0<= X<45.9999...
0<=(int) X<45

temp=Lotto[idx];	
Lotto[idx]=Lotto[0];
Lotto[0]=temp;

3,1,10,6,30,19
============================================================

다량의 데이터를 처리하는 방법

1. 배열 -> 순서, 같은 자료형..., 갯수를 정한다.
2. 컬렉션 -> List, Set, Map, Vextor, Stac (컬렉션 프레임 워크)
3. 


***다차원 배열
//int형 data를 저장할 수 있는 3행4열의 배열 
int[][] arr1=new int[3][4];
 
          0열     1열    2열   3열
0행     (0,0)   (0,1)   (0,2)   (0,3)    
1행     (1,0)   (1,1)   (1,2)   (1,3)
2행     (2,0)   (2,1)   (2,2)   (2,3)
3행     (3,0)   (3,1)   (3,2)   (3,3)

{
           //1열 2열 3열 4열
	{1,2,3,4}         //0행
              {5,6,7,8}        //1행
              {9,10,11,12}   //2행
}
arr1[0][0]   //="1"

============================================================
객체지향언어(Object Oriented Programing) -> OOP
============================================================
절차 지향언어 >> 작업 순서(알고리즘)를 표현(함수들의 집합으로 프로그래밍)
객체 지향언어 >> "미리 사용 할 목적으로 설계도를 완성하고 그 객체를 이용해서 프로그래밍"

클래스: "객체를 만들기 위한 설계도", "객체의 속성과 기능 선언" <틀>
객체(Object, 인스턴스(instance))  : 실제, 추상 >> 모든 것.. "클래스를 통해 만들어진... 실체"

============================================================

객체지향언어(C++, 자바)
1. 설계도(클래스)
2. 객체를 생성(클래스를 통해서)
3. 객체의 여러성질(☆다형성,상속,캡슐화...☆) 프로그래밍

절차지향언어(C언어) ->시스템 개발
1. 함수
2. 알고리즘
3. 자료구조 이해

클래스 ->사용자정의타입

int i;
char ch; 

클래스명 변수;   //(객체 참조 변수: 객체의 주소값이 저장)


int[] arr1=new int[5]
String str1=new String();


접근지정자(접근제한자) class 클래스명{
	필드;	//프로퍼티, 속성
	//생성자;	//생략할 경우 기본 생성자
	매서드;
}
============================================================

	객체 생성연산자 ->주소값 생성
	      new -> 인스턴스화(객체화) 
ClassBasic c1=new ClassBasic();

자바 맴버: 필드, 생성자, 매서드
. -> 객체접근 연산자(맴버에 접근할 수 있음)

필드 -하나의 데이터 
매서드 () - 괄호

============================================================

***클래스명명 규칙
1.대문자로 시작한다.(약속)
2.한글을 사용하지 말자.(약속)
3.특수기회는 _$이외는 사용 할 수 없다.
4.공백을 허용하지 않는다.
5.단어단어의 첫글자는 대문자로 시작한다.

============================================================

**자바의 메모리영역

1)Method 영역(클래스 영역)-> 클래스가 생성되면 생성, 클래스가 소멸되면 소멸
JVM이 실행되면서 생기는 공간
Class, 전역변수, Static변수 정보가 저장되는 공간이다.
->공유 공간

2) Heap-> new 생성
new 연산자로 생성된 객체 , Array 동적으로 생성된 데이터가 저장되는 공간
Heap에 저장된 데이터는 Garbage Collection 처리
Reference Type의 데이터가 저장공간

3)Stack
지역변수, 매소드의 매개변수와 임시 데이터가 저장되는 공간
Last in First Out ->

4)PC Register
스레드가 생성되면서 생기는 공간

5)Native Method Stack
Java가 아닌 다른 언어(C,C++)로 구성된 매소드를 실행이 필요할 때 사용되는 공간

============================================================

클래스 실습

Car

이름 carName
가격 carCoin
색상 carColor
배기량 carCC

carInfo()

Weight
Radius
Color
============================================================
============================================================

Package ->비슷한 기능의 클래스를 그룹화시킨 디렉토리
**다른 패키지 클래스에 접근하기 위해서는 import문을 사용한다.
import org.study.DBMemberCommend.*;
**이클립스는 자동으로 import 해준다.
**패키지를 생성하지 않을 시 default package에 자동으로 저장된다.

============================================================

패키지 ->org.study.package1, org.study.package2

============================================================

==접근제한자(접근지정자, Modify)==

클래스
public 모든 패키지 클래스에서 접근
default(생략):  package-private 같은 패키지내의 클래스만 접근

맴버(클래스내부)
public		다른패키지에서도 사용가능	
protected		상속관계, 같은 패키지
default 		같은 패키지
private		같은 클래스에서만 사용가능 ->캡슐화 -> 보안, 보호,DB관련 DTO, Entity


                   같은패키지   	다른패키지       상속          같은클래스  
public		O	      O	          O	                O
protected		O                 X                O                  O
default(생략)	O                 X                X                  O
private                  X                  X                X                  O



대부분의 DB 관련 맴버는 priavte ->필드
매서드->private 필드를 외부에서 접근가능하는 매서드***
setter
getter
***lombok.jar-> spring

==============================

Ex)
패키지 4개
org.study.DBMemberDto ->
	DBMemberDTO클래스
		private String userld
		private String userPw
		private int userAge
		private String userName
		private String userAddr

org.study.DBMemberDao ->2
org.study.DBMemberCommend ->3
org.study.DBMemberCoroller ->4

***갯수가 정해지지 않는 객체는 Collection을 이용해서 저장
============================================================
맴버
1. 필드
인스턴스맴버: 객체가 생성되면 생성되고 객체가 소멸되면 종료
클래스맴버: 클래스가 생성되면 생성되고 클래스가 소멸되면 종료

인스턴스 맴버(new 에서 생성)
클래스타입 객체참조변수 =new생성자();
//인스턴스화(객체화)
String str=new String("manso");
str.맴버;//

클래스맴버
클래스명.맴버;

**final 상수 ->한번만 초기화
**반드시 초기화를 해야된다.
**대문자로 작성
**클래스의 공용데이터
public static final String PROTECTNAME="프로젝트명";

2.맴버(매서드)

접근지정자 반환타입 매서드명(입력인자){
	
	return반환값;	//반환값이 없으면 생략

}
//선언부
public void instanceMethod(String name){ //인스턴스 매서드
		//구현부
	System.out.println(name+"인스턴스매서드2");
}

**반환타입 -> return 값과 타입이 같아야된다.
void-> return; //생략

***매서드를 호출한 곳에 return값이 반환된다. void면 실행만 된다.
***static 매서드는 -> static맴버'만' 접근가능 (final 붙이면 반드시 초기화를 해줘야한다.-변동X)
***non-static 매서드는 -> static맴버도 접근가능( 다 접근 가능)
============================================================

지역변수(logical): 매서드 안에서 선언된 변수, 매개변수
1. 매서드가 생성되면 반드시 초기화해야된다.
2. 매서드와 생성과 종료시기가 같다.
3. 스택메모리에 저장.

============================================================

***캡슐화
**private 맴버(필드)에 접근 가능한 매서드->보안, 보호
setters, getters를 사용해서 프라이빗을 가져와서 사용한다.

set~설정
get~호출

	public void set~(String userId){
	this.
	}
	//setter -> private 필드를 외부에 초기화 매서드
	public void setUserId(String userId) {
		
	//      필드 =매개변수(외부입력)
	  this.userId=userId;
	}

	//getter -> private 필드를 외부에 호출 매서드
	public String getUserId() {
		return this.userId;
	}

------------------------------------------------------------------------

ins1.setUserId("m111");
		String userId = ins1.getUserId();
		System.out.println(userId);

============================================================

***
1. 인스턴스맴버: 클래스 내부의 변수 -> 인스턴스를 생성한 후 접근 가능 
2. 클래스 맴버: 인스턴스 생성하지 않아도 접근가능 (Static 선언)
3. 지역변수(매서드 안에 선언) :매서드의 안의 변수
4. 지역변수(매개인자)	:매서드 매개인자
5. 객체참조변수		:객체(인스턴스)의 주소값을 저장

============================================================

***상수 ->상수랑 수식에서 변하지 않는 값을 의미한다.
상수의 선언
final 상수타입 상수명;
final static int MAN;

============================================================

==오버로딩(OverLoading)== -> java에서 허용
***매서드 이름이 같은 것을 허용한다.

.매서드의 구현부에서 매서드명이 똑같다.
.매서드의 매개인자 유형(타입)이 다른 매서드
.매서드의 매개인자 갯수가 다른 매서드

//선언부
public void method1(){
//구현부
}
public void method1(int num1){
}
public void method1(int num1,String name){
}
public void method1(String name, int num1){
}
============================================================
============================================================

생성자(construct)

1.매서드다. >> 클래스 이름과 똑같은 매서드다
2.반환타입 void다. >> 그래서 생략 public 클래스 (){}
3.객체를 생성할때 도움을 주기 위한 매서드
4.컴파일러가 자동으로 생성해준다.(기본 생성자)
5.☆★☆다른 생성자를 생성할 시 기본생성자는 자동으로 생성하지 않는다.☆★☆
6.오버로딩을 허용
7.다른 생성자를 호출시 반드시 생성자의 첫번째 줄에서 호출한다.
ex) this() this(인자) this(인자, 인자)

***this()
-같은 클래스의 다른 생성자 호출
-생성자 내에서만 사용
-생성자의 제일 첫번째 줄에서만 호출
***this.필드

============================================================
EX1)
//예) Scanner 이용해서 회원가입하고 회원가입 정보를 콘솔에 출력
	//아이디, 비밀번호, 나이를 입력하고 콘솔에 id:m11, password:m11, age:1111
	//exit입력되면 while문을 종료
	//setter, getter

while(true),조건문 (if)
1)"회원가입하시겠습니까?"
	실행 ->회원가입->회원출력
	실행하지 않으면 ->회원가입종료
2) .close();

EX2)
//예) Scanner 이용해서 로그인
	// id:m11, password:1111
	
	//아이디와 비밀번호가 같으면 "로그인 성공" ->콘솔에 출력
	//아이디와 비밀번호가 다르면 "로그인 실패, 다시 로그인하세요. " ->콘솔에 출력
	//로그인 실행하지 않으면 ->종료

while(true),조건문 (if)
1)"로그인 하시겠습니까?"
	실행 ->로그인 실행
	실행하지 않으면 ->로그인 종료
2) .close();

============================================================
============================================================

==상속(inheritance)==
1. "부모(슈퍼)클래스의 맴버(필드,매소드)를 자식(서브)클래스에 물려주는 것"
2. 클래스간의 단일 상속만 가능
3. 자식클래스의 맴버의 수는 반드시 부모클래스보다 크거나 같다.
4. 자식클래스 extends 부모클래스
5. 모든 생성자를 상속하지는 않는다.
6. 상속시 기본생성자는 자식생성자 첫번째 줄에 자동으로 생성해준다.
7. 상속시 부모클래스의 생성자는 자식클래스 생성자의 첫번째에 생성해주어야한다.
8. 모든 클래스는 기본적으로 Object클래스를 상속 받는다.
	클래스 extends Object -> 생략(기본)***
9. Final클래스는 상속할 수 없다.

============================================================

***생성자 상속시

오버라이드..(오버라이딩)
"상속관계에서 부모의 매서드를 자식객체에서 재정의 사용"

1. 매서드 선언부가 똑같다.
2. 매서드 구현부를 재 정의 하는 방식
3. @Override 어노테이션 이용해서 오버라이드 되었음을 알려준다.
4. 오버라이드 된 매서드는 자식매서드가 구현
5. 단. super 키워드를 사용하면 부모매서드도 구현가능

***@어노테이션

CRUD
create	회원 가입
read	회원 조회
update	회원 수정
delete	회원 삭제


============================================================

***응용소프트웨어 개발 방식(디자인 패턴)
MVC(Model View Controller) 패턴
->Model2 

============================================================

***다형성(Polymorphism) -> 상속, 오버라이딩
-> "부모타입의 객체참조 변수로 자식 객체를 참조할 수 있는 것"
->참조할 수 있는 범위는 부모타입의 맴버만 참조할 수 있다. 
**같은 이름의 매서드가 클래스 혹은 객체에 따라 다르게 구현
**매서드 오버로딩: 매서드 명이 같고 매개변수 유형, 갯수 상이
**매서드 오버라이딩: 상속을 통해서 부모(슈퍼)클래스의 매서드를 구현

장점
-> 유지보수가 쉽다.
-> 재사용증가 

============================================================
***추상클래스(abstract Class)
1. 추상매서드가 있는 클래스( 미완성, 공통, abstract)
2. 객체를 생성하지 못한다.(new)
3. 맴버(일반클래스맴버+추상매서드)
4. 다른 클래스에게 도움을 주기 위한 클래스(강제성)
5. 상속을 통해서 반드시 추상매서드를 오버라이드 해서 구현 시킨다.***
6. 구현 객체를 통해서 구현 한다.***
7. 추상클래스 상속시(클래스의 유형을 선택)
   **추상클래스로 설정(다시 추상클래스화)
   **일반클래스에서 추상매서드를 오버라이드 설정
8. 단일 상속만 허용
==============================
추상클래스 1 -> 추상매서드 1
구현클래스 4
main클래스
==============================
Scanner
while(true), if, switch 이용

입력
"insert"면 콘솔에 회원가입
"update"면 콘솔에 회원수정
"delete"면 콘솔에 회원삭제
"select"면 콘솔에 회원조회


============================================================
***인터페이스(interface)
1. 맴버 (추상매서드, final상수, default, static 매서드만)
2. 객체를 생성하지 못한다. (new 생성 X)
3. 다중 상속이 가능(extands) 인터페이스간의 상속시
   인터페이스 extends 인터페이스 (인터페이스간의 상속시-다중상속)
   클래스 implements 인터페이스(다중구현)
   클래스 implements interface1, interface2,,,,
4. 구현 객체를 상속을 통해 반드시 추상매서드를 구현 (오버라이드)
5. 다형성을 이용해서 프로그래밍
6. 안드로이드나 게임 분야의 특정 기능들을 구현
7. 인터페이스 상속시(타입의 유형을 선택)
	**인터페이스로 설정(다시 인터페이스화) -> 추상클래스
	**일반클래스에서 추상매서드를 오버라이드 설정

*인터페이스 장점
1. 개발시간 단축
2. 표준화가 가능
3. 관계있는 클래스 간의 연결
4. 독립적인 프로그래밍이 가능

***Web application 제작시 필수 사용 요소
    Model2 방식 -> service(commend), Repository(Spring boot)
    
***기본적으로 접근지정자(제한자) ->public -> 생략가능
    public interface InterfaceEx1{}
    interface InterfaceEx1{}    

인터페이스1 -> implements 구현객체

메인클래스를 생성한 후 -> 
new 구현객체() -> 인터페이스1 오버라이딩 매서드 구현

**static -> 클래스명.맴버, 인스턴스.맴버
-> DBConnect -> 데이터베이스 연동 시 JDBC

==============================
		맴버		      객체	        상속	오버라이드		
추상클래스: 일반클래스 맴버, 추상매서드      newX      단일상속 만	필수(추상)
인터페이스: 추상매서드, final, static, default   newX     다중상속 가능	필수(추상)


**final 상수는 반드시 값을 초기화 해야한다.

**클래스 간에
abstract class A extends 단일상속{}
**인터페이스 간에
interface lnter1 extends 다중상속{}
interface lnter1 extends inter2, inter2,,,{}

**인터페이스 구현 ->구현 클래스
클래스 implements 인터페이스(다중화)

===========================================================
**만들고자 하는 웹 어플리케이션 생각해보자.. "관리자 페이지, 알바비 계산"

프로젝트 구조
**설계 -> 모델링, UML
DB 모델링 -> ERD(Entity RelationShip Diagram)

1. 패키지
패키지 5개
org.study.controller	->"일 시키고 결과를 View에 반환"
org.study.commend	->"컨트롤러의 지시로 일을 수행" ->DB관련 ->Dao에서 처리
	CRUD -> java Web -> 기본
	Creat	->생성, 추가 ->insert
	Read	->조회 ->select
	Update	->수정 ->update
	Delete	->삭제 ->delete

	interface	-> void excuteCommend(); //강제실행

org.study.dto	->"DB 테이블과 연동하는 클래스" ->spring boot entity
org.study.dao	->"DB에 접근해서 실제 DB관련 처리하고 반환"
org.study.dbconnect	->"DB 연결" -> JDBC, DBCP(커넥션풀), spring JDBC, Mybatis, JPA

2.패키지 -> 클래스	

============================================================

자바API(Java API)는 자바를 사용하여 쉽게 구현할 수 있도록한 클래스 라이브러리의 집합이다.
즉, 자바라는 언어를 사용하여 사용자의 부담을 최소화하는 반면에 입출력, 화면 구성, 이미지,
네트워크와 같이 복잡하지만 필요한 클래스들을 미리 구현하여 사용자가 쉽게 구현하도록하는
API이다. 이러한 자바API는 하나의 커다란 클래스 계층구조로 설계되어있다.

java.lang -> 기본
자바 프로그래밍을 위한 가장 기본적인 패키지와 클래스, 인터페이스를 포함하고 있다.
java.util -> 유용한
프로그램을 제어하기 위한 클래스와 데이터를 효율적으로 저장하기 위한 클래스들을 담고 있다
java.io -> 입출력
키보드, 모니터, 프린터, 파일등을 제어할 수 있는 클래스들의 모음

자바
1.프로젝트 기본구조
2.반드시 하나 이상의 패키지로 이루어졌다.(default package)
3.패키지 서로 연관있는 클래스와 인터페이스로 구성

==============================

**패키지, import문
1. 다른패키지로 작성된 클래스
1)import 하지 않을 경우 ->전체 패키지 경로.class명
2)필요한 클래스만 import ->import패키지 경로.class명
3)모든클래스 import -> import패키지경로.*;

2. 같은 패키지, java.lang은 생략가능

==============================

java.lang.*; //
**Object
1.모든 클래스의 슈퍼클래스(자동 컴파일)
2. 모든 클래스가 Object클래스의 매서드를 상속
3. 주요 매서드
hashCode()  >>객체의 해시코드 값을 리턴(객체마다 다르다) ->고유값
getClass() >> 객체의 클래스 정보 getName() "클래스의 이름"
toString() >> 클래스의 객체를 문자열로 나타낸다.

==============================
boolean equals(Object obj) 	obj가 가르키는 객체와 현재 객체를 비교하여 같으면 true 리턴
Class getClass() 		현 객체의 런타임 클래스를 리턴
int hashCode()		현 객체에 대한 해시 코드값 리턴
String toString() 		현 객체에 대한 문자열 표현을 리턴
void notify() 		현객체에 대해 대기하고 있는 하나의 스레드를 깨운다
void notifyAll() 		현 객체에 대기하고 있는 모든 스레드를 깨운다
void wait 			다른 스레드가 깨울 때 까지 현재 스레드를 대기하게 한다.
















===다음 주 자바===
추상클래스의 "개념"
인터페이스***
중첩 클래스 -> 내부클래스
무명클래스(익명클래스) -> 이름 없는 클래스 -> 한가지 기능 구현
예외처리(Exception)
기본패키지

JDBC: 자바언어를 오라클로 연동하는 프로그램
하면서 오라클 들어가요.























==============================